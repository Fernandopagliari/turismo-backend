# build_deploy.py
import os
import subprocess
import sys
import shutil
from PyQt5.QtWidgets import (QDialog, QVBoxLayout, QHBoxLayout, QLabel, 
                             QPushButton, QTextEdit, QProgressBar, QMessageBox,
                             QGroupBox, QComboBox)
from PyQt5.QtCore import Qt, QThread, pyqtSignal
import threading

# Importar la conexi√≥n a la base de datos
try:
    from database_local import conectar_local, obtener_configuracion_hosting
    BD_DISPONIBLE = True
except ImportError:
    BD_DISPONIBLE = False

class BuildDeployThread(QThread):
    """Hilo para ejecutar build y deploy sin bloquear la UI"""
    log_signal = pyqtSignal(str)
    progress_signal = pyqtSignal(int)
    finished_signal = pyqtSignal(bool, str)
    
    def __init__(self, project_path, deploy_config=None):
        super().__init__()
        self.project_path = project_path
        self.deploy_config = deploy_config or {}
        
        # Rutas posibles del proyecto
        self.possible_paths = [
            project_path,  # Ra√≠z del proyecto
            os.path.join(project_path, "src"),
            os.path.join(project_path, "frontend"),
        ]
        
        self.project_root = self.encontrar_project_root()
        self.dist_path = os.path.join(self.project_root, "dist") if self.project_root else None
        
        # ‚úÖ Encontrar npm y node
        self.npm_path = self.encontrar_npm()
        self.node_path = self.encontrar_node()
        
    def encontrar_npm(self):
        """Encontrar la ruta de npm"""
        # Buscar npm en diferentes ubicaciones
        posibles_rutas = [
            "npm",  # En PATH
            r"C:\Program Files\nodejs\npm.cmd",
            r"C:\Program Files (x86)\nodejs\npm.cmd",
            os.path.join(os.environ.get('APPDATA', ''), "npm", "npm.cmd"),
        ]
        
        for ruta in posibles_rutas:
            try:
                result = subprocess.run([ruta, "--version"], capture_output=True, text=True)
                if result.returncode == 0:
                    print(f"‚úÖ npm encontrado en: {ruta}")
                    return ruta
            except:
                continue
        
        print("‚ùå npm no encontrado")
        return None
    
    def encontrar_node(self):
        """Encontrar la ruta de node"""
        # Buscar node en diferentes ubicaciones
        posibles_rutas = [
            "node",  # En PATH
            r"C:\Program Files\nodejs\node.exe",
            r"C:\Program Files (x86)\nodejs\node.exe",
        ]
        
        for ruta in posibles_rutas:
            try:
                result = subprocess.run([ruta, "--version"], capture_output=True, text=True)
                if result.returncode == 0:
                    print(f"‚úÖ node encontrado en: {ruta}")
                    return ruta
            except:
                continue
        
        print("‚ùå node no encontrado")
        return None
        
    def encontrar_project_root(self):
        """Encontrar la ra√≠z del proyecto React (donde est√° package.json)"""
        for path in self.possible_paths:
            if os.path.exists(path):
                package_json = os.path.join(path, "package.json")
                if os.path.exists(package_json):
                    print(f"‚úÖ Encontrado package.json en: {path}")
                    return path
                else:
                    print(f"‚ùå package.json no encontrado en: {path}")
        
        return None
        
    def run(self):
        try:
            self.log_signal.emit("üöÄ INICIANDO PROCESO DE BUILD & DEPLOY")
            self.log_signal.emit("=" * 50)
            
            # Paso 1: Verificar que encontramos el proyecto
            if not self.project_root:
                error_msg = f"‚ùå No se pudo encontrar el proyecto React.\n"
                error_msg += f"Buscado en:\n"
                for path in self.possible_paths:
                    error_msg += f"  - {path}\n"
                error_msg += f"üí° Aseg√∫rate de que package.json existe en una de estas rutas"
                self.finished_signal.emit(False, error_msg)
                return
                
            self.log_signal.emit(f"‚úÖ Proyecto encontrado en: {self.project_root}")
            
            # Paso 2: Verificar npm y node
            if not self.npm_path or not self.node_path:
                error_msg = "‚ùå Node.js o npm no encontrados.\n"
                error_msg += "üí° Instala Node.js desde: https://nodejs.org/\n"
                error_msg += "üí° O aseg√∫rate de que est√°n en el PATH del sistema"
                self.finished_signal.emit(False, error_msg)
                return
                
            self.log_signal.emit(f"‚úÖ Node.js encontrado: {self.node_path}")
            self.log_signal.emit(f"‚úÖ npm encontrado: {self.npm_path}")
                
            # Paso 3: Navegar al directorio del proyecto
            os.chdir(self.project_root)
            self.log_signal.emit(f"üìÅ Directorio de trabajo: {self.project_root}")
            
            # Paso 4: Mostrar configuraci√≥n de deploy
            if self.deploy_config:
                self.log_signal.emit(f"üåê Configuraci√≥n de deploy: {self.deploy_config.get('base_url', 'No configurado')}")
            
            # Paso 5: Instalar dependencias si es necesario
            self.log_signal.emit("üì¶ Verificando dependencias...")
            self.progress_signal.emit(10)
            
            if not self.verificar_dependencias():
                self.log_signal.emit("‚ö†Ô∏è Instalando dependencias...")
                if not self.instalar_dependencias():
                    self.finished_signal.emit(False, "Error instalando dependencias")
                    return
            
            self.progress_signal.emit(30)
            
            # Paso 6: Ejecutar build
            self.log_signal.emit("üî® Ejecutando build...")
            if not self.ejecutar_build():
                self.finished_signal.emit(False, "Error en el build")
                return
                
            self.progress_signal.emit(70)
            
            # Paso 7: Deploy (solo si hay configuraci√≥n)
            if self.deploy_config and self.deploy_config.get('base_url'):
                self.log_signal.emit("‚òÅÔ∏è Realizando deploy...")
                if not self.ejecutar_deploy():
                    self.finished_signal.emit(False, "Error en el deploy")
                    return
            else:
                self.log_signal.emit("‚ÑπÔ∏è  Solo build - No hay configuraci√≥n de deploy")
                
            self.progress_signal.emit(100)
            self.finished_signal.emit(True, "‚úÖ Build & Deploy completado exitosamente!")
            
        except Exception as e:
            self.finished_signal.emit(False, f"‚ùå Error: {str(e)}")
    
    def verificar_dependencias(self):
        """Verificar si node_modules existe"""
        node_modules_path = os.path.join(self.project_root, "node_modules")
        existe = os.path.exists(node_modules_path)
        self.log_signal.emit(f"üì¶ node_modules existe: {existe}")
        return existe
    
    def instalar_dependencias(self):
        """Ejecutar npm install"""
        try:
            self.log_signal.emit("üì• Instalando dependencias con npm install...")
            
            # Usar la ruta completa de npm
            comando = [self.npm_path, "install"]
            
            result = subprocess.run(comando, 
                                  capture_output=True, text=True, 
                                  timeout=300,  # 5 minutos
                                  shell=True)  # ‚úÖ Usar shell para acceso a PATH
            
            if result.returncode == 0:
                self.log_signal.emit("‚úÖ Dependencias instaladas correctamente")
                if result.stdout:
                    self.log_signal.emit(f"üìã Output: {result.stdout[-200:]}")  # √öltimas 200 chars
                return True
            else:
                self.log_signal.emit(f"‚ùå Error instalando dependencias")
                if result.stderr:
                    self.log_signal.emit(f"üî¥ Stderr: {result.stderr}")
                if result.stdout:
                    self.log_signal.emit(f"üü° Stdout: {result.stdout}")
                return False
                
        except subprocess.TimeoutExpired:
            self.log_signal.emit("‚ùå Timeout instalando dependencias")
            return False
        except Exception as e:
            self.log_signal.emit(f"‚ùå Error: {str(e)}")
            return False
    
    def ejecutar_build(self):
        """Ejecutar npm run build"""
        try:
            self.log_signal.emit("üèóÔ∏è Ejecutando npm run build...")
            
            # Limpiar dist anterior si existe
            if os.path.exists(self.dist_path):
                shutil.rmtree(self.dist_path)
                self.log_signal.emit("üóëÔ∏è Carpeta dist anterior eliminada")
            
            # Usar la ruta completa de npm
            comando = [self.npm_path, "run", "build"]
            
            result = subprocess.run(comando, 
                                  capture_output=True, text=True, 
                                  timeout=300,  # 5 minutos
                                  shell=True)  # ‚úÖ Usar shell para acceso a PATH
            
            if result.returncode == 0:
                self.log_signal.emit("‚úÖ Build completado exitosamente")
                self.log_signal.emit(f"üìÇ Carpeta dist creada en: {self.dist_path}")
                
                # Mostrar informaci√≥n del build
                if os.path.exists(self.dist_path):
                    tama√±o = self.get_folder_size(self.dist_path)
                    self.log_signal.emit(f"üìä Tama√±o del build: {tama√±o}")
                    
                    # Mostrar archivos generados
                    archivos = self.listar_archivos_dist()
                    self.log_signal.emit(f"üìÑ Archivos generados: {', '.join(archivos)}")
                    
                return True
            else:
                self.log_signal.emit(f"‚ùå Error en build")
                if result.stderr:
                    self.log_signal.emit(f"üî¥ Stderr: {result.stderr}")
                if result.stdout:
                    self.log_signal.emit(f"üü° Stdout: {result.stdout}")
                return False
                
        except subprocess.TimeoutExpired:
            self.log_signal.emit("‚ùå Timeout en build")
            return False
        except Exception as e:
            self.log_signal.emit(f"‚ùå Error: {str(e)}")
            return False
    
    def ejecutar_deploy(self):
        """Ejecutar deploy basado en la configuraci√≥n de la BD"""
        try:
            base_url = self.deploy_config.get('base_url', '')
            
            if not base_url:
                self.log_signal.emit("‚ö†Ô∏è  No hay base_url configurado para deploy")
                return True
            
            # Determinar el tipo de deploy basado en el base_url
            if 'railway' in base_url:
                return self.deploy_railway()
            elif 'netlify' in base_url:
                return self.deploy_netlify()
            elif 'vercel' in base_url:
                return self.deploy_vercel()
            else:
                # Deploy gen√©rico (FTP, SSH, etc.)
                return self.deploy_generico()
                
        except Exception as e:
            self.log_signal.emit(f"‚ùå Error en deploy: {str(e)}")
            return False
    
    def deploy_railway(self):
        """Deploy autom√°tico a Railway"""
        try:
            self.log_signal.emit("üöÇ Desplegando a Railway...")
            
            # Verificar que railway CLI est√° instalado
            result = subprocess.run(["railway", "--version"], 
                                  capture_output=True, text=True,
                                  shell=True)  # ‚úÖ Usar shell
            
            if result.returncode != 0:
                self.log_signal.emit("‚ùå Railway CLI no encontrado. Instala con: npm install -g @railway/cli")
                self.log_signal.emit("üí° Deploy manual requerido")
                return True  # No es error cr√≠tico, solo build
            
            # Deploy con railway
            result = subprocess.run(["railway", "deploy"], 
                                  capture_output=True, text=True, 
                                  timeout=600,
                                  shell=True)  # ‚úÖ Usar shell
            
            if result.returncode == 0:
                self.log_signal.emit("‚úÖ Deploy a Railway completado")
                self.log_signal.emit(f"üåê Aplicaci√≥n disponible en: {self.deploy_config.get('base_url')}")
                return True
            else:
                self.log_signal.emit(f"‚ùå Error en deploy Railway: {result.stderr}")
                self.log_signal.emit("üí° Deploy manual requerido")
                return True  # No es error cr√≠tico, solo build
                
        except subprocess.TimeoutExpired:
            self.log_signal.emit("‚ùå Timeout en deploy Railway")
            return True
        except Exception as e:
            self.log_signal.emit(f"‚ùå Error: {str(e)}")
            return True
    
    def deploy_netlify(self):
        """Deploy a Netlify"""
        self.log_signal.emit("‚òÅÔ∏è  Configuraci√≥n Netlify detectada")
        self.log_signal.emit("üí° Deploy manual requerido para Netlify")
        self.log_signal.emit(f"üîó Sube la carpeta 'dist' a: {self.deploy_config.get('base_url')}")
        return True
    
    def deploy_vercel(self):
        """Deploy a Vercel"""
        self.log_signal.emit("‚ñ≤ Configuraci√≥n Vercel detectada")
        self.log_signal.emit("üí° Deploy manual requerido para Vercel")
        self.log_signal.emit(f"üîó Sube la carpeta 'dist' a: {self.deploy_config.get('base_url')}")
        return True
    
    def deploy_generico(self):
        """Deploy gen√©rico"""
        self.log_signal.emit("üåê Configuraci√≥n de deploy gen√©rico")
        self.log_signal.emit(f"üîó URL de producci√≥n: {self.deploy_config.get('base_url')}")
        self.log_signal.emit("üí° Sube manualmente la carpeta 'dist' a tu servidor")
        return True
    
    def get_folder_size(self, folder_path):
        """Calcular tama√±o de carpeta en MB"""
        try:
            total_size = 0
            for dirpath, dirnames, filenames in os.walk(folder_path):
                for filename in filenames:
                    filepath = os.path.join(dirpath, filename)
                    total_size += os.path.getsize(filepath)
            
            size_mb = total_size / (1024 * 1024)
            return f"{size_mb:.2f} MB"
        except:
            return "Desconocido"
    
    def listar_archivos_dist(self):
        """Listar archivos principales en dist"""
        try:
            if not os.path.exists(self.dist_path):
                return ["No existe dist"]
            
            archivos = []
            for item in os.listdir(self.dist_path):
                if os.path.isfile(os.path.join(self.dist_path, item)):
                    archivos.append(item)
                elif os.path.isdir(os.path.join(self.dist_path, item)):
                    archivos.append(f"{item}/")
            
            return archivos[:5]  # Solo primeros 5 archivos
        except:
            return ["Error listando archivos"]

class DialogoBuildDeploy(QDialog):
    """Di√°logo para build y deploy autom√°tico"""
    
    def __init__(self, parent=None, project_path=None):
        super().__init__(parent)
        # ‚úÖ CORREGIDO: Apuntar a la ra√≠z del proyecto (donde est√° package.json)
        self.project_path = project_path or r"E:\Sistemas de app para androide\turismo-app"
        self.deploy_config = None
        self.setup_ui()
        self.cargar_configuracion_desde_bd()
        
    def setup_ui(self):
        self.setWindowTitle("üöÄ Build & Deploy Autom√°tico")
        self.setFixedSize(700, 600)
        
        layout = QVBoxLayout()
        
        # T√≠tulo
        titulo = QLabel("Sistema Autom√°tico de Build & Deploy")
        titulo.setStyleSheet("font-size: 16px; font-weight: bold; color: #2c3e50; margin: 10px;")
        layout.addWidget(titulo)
        
        # Informaci√≥n del proyecto
        info_group = QGroupBox("üìã Informaci√≥n del Proyecto")
        info_layout = QVBoxLayout()
        
        self.lbl_proyecto = QLabel(f"üìÅ Proyecto: {self.project_path}")
        self.lbl_deploy = QLabel("üåê Deploy: Cargando configuraci√≥n...")
        self.lbl_url = QLabel("üîó URL: Cargando...")
        
        info_layout.addWidget(self.lbl_proyecto)
        info_layout.addWidget(self.lbl_deploy)
        info_layout.addWidget(self.lbl_url)
        
        info_group.setLayout(info_layout)
        layout.addWidget(info_group)
        
        # Log output
        layout.addWidget(QLabel("üìù Log de ejecuci√≥n:"))
        self.log_output = QTextEdit()
        self.log_output.setReadOnly(True)
        self.log_output.setStyleSheet("font-family: 'Courier New'; font-size: 10px;")
        layout.addWidget(self.log_output)
        
        # Progress bar
        self.progress_bar = QProgressBar()
        self.progress_bar.setVisible(False)
        layout.addWidget(self.progress_bar)
        
        # Botones
        botones_layout = QHBoxLayout()
        
        self.btn_build_only = QPushButton("üî® Solo Build")
        self.btn_build_only.clicked.connect(lambda: self.iniciar_proceso(None))
        self.btn_build_only.setStyleSheet("""
            QPushButton {
                background-color: #3498db;
                color: white;
                padding: 8px 15px;
                border: none;
                border-radius: 4px;
                font-weight: bold;
            }
            QPushButton:hover { background-color: #2980b9; }
            QPushButton:disabled { background-color: #bdc3c7; }
        """)
        
        self.btn_build_deploy = QPushButton("üöÄ Build + Deploy")
        self.btn_build_deploy.clicked.connect(lambda: self.iniciar_proceso(self.deploy_config))
        self.btn_build_deploy.setStyleSheet("""
            QPushButton {
                background-color: #27ae60;
                color: white;
                padding: 8px 15px;
                border: none;
                border-radius: 4px;
                font-weight: bold;
            }
            QPushButton:hover { background-color: #219a52; }
            QPushButton:disabled { background-color: #bdc3c7; }
        """)
        
        self.btn_cerrar = QPushButton("‚ùå Cerrar")
        self.btn_cerrar.clicked.connect(self.close)
        self.btn_cerrar.setStyleSheet("""
            QPushButton {
                background-color: #e74c3c;
                color: white;
                padding: 8px 15px;
                border: none;
                border-radius: 4px;
                font-weight: bold;
            }
            QPushButton:hover { background-color: #c0392b; }
        """)
        
        botones_layout.addWidget(self.btn_build_only)
        botones_layout.addWidget(self.btn_build_deploy)
        botones_layout.addWidget(self.btn_cerrar)
        layout.addLayout(botones_layout)
        
        self.setLayout(layout)
        
        # Thread
        self.build_thread = None
    
    def cargar_configuracion_desde_bd(self):
        """Cargar configuraci√≥n de deploy desde la base de datos"""
        try:
            if not BD_DISPONIBLE:
                self.actualizar_ui_configuracion(None, "Base de datos no disponible")
                return
            
            config = obtener_configuracion_hosting()
            if config:
                self.deploy_config = config
                base_url = config.get('base_url', 'No configurado')
                host = config.get('host', 'Desconocido')
                
                self.actualizar_ui_configuracion(base_url, host)
                self.log(f"‚úÖ Configuraci√≥n cargada desde BD: {base_url}")
            else:
                self.actualizar_ui_configuracion(None, "No hay configuraci√≥n de hosting")
                self.log("‚ö†Ô∏è  No se encontr√≥ configuraci√≥n de deploy en la BD")
                
        except Exception as e:
            self.actualizar_ui_configuracion(None, f"Error: {str(e)}")
            self.log(f"‚ùå Error cargando configuraci√≥n: {str(e)}")
    
    def actualizar_ui_configuracion(self, base_url, host_info):
        """Actualizar la UI con la configuraci√≥n cargada"""
        if base_url:
            self.lbl_deploy.setText(f"üåê Deploy: {host_info}")
            self.lbl_url.setText(f"üîó URL: {base_url}")
            self.btn_build_deploy.setEnabled(True)
        else:
            self.lbl_deploy.setText("üåê Deploy: No configurado")
            self.lbl_url.setText("üîó URL: No configurado")
            self.btn_build_deploy.setEnabled(False)
    
    def log(self, mensaje):
        """Agregar mensaje al log"""
        self.log_output.append(f"{mensaje}")
        # Auto-scroll
        cursor = self.log_output.textCursor()
        cursor.movePosition(cursor.End)
        self.log_output.setTextCursor(cursor)
    
    def iniciar_proceso(self, deploy_config):
        """Iniciar proceso de build/deploy"""
        # Deshabilitar botones
        self.btn_build_only.setEnabled(False)
        self.btn_build_deploy.setEnabled(False)
        
        # Mostrar progress bar
        self.progress_bar.setVisible(True)
        self.progress_bar.setValue(0)
        
        # Limpiar log anterior
        self.log_output.clear()
        
        # Crear y ejecutar thread
        self.build_thread = BuildDeployThread(self.project_path, deploy_config)
        self.build_thread.log_signal.connect(self.log)
        self.build_thread.progress_signal.connect(self.progress_bar.setValue)
        self.build_thread.finished_signal.connect(self.proceso_finalizado)
        self.build_thread.start()
    
    def proceso_finalizado(self, exito, mensaje):
        """Callback cuando termina el proceso"""
        # Habilitar botones
        self.btn_build_only.setEnabled(True)
        self.btn_build_deploy.setEnabled(True)
        
        # Ocultar progress bar
        self.progress_bar.setVisible(False)
        
        # Mostrar mensaje final
        self.log(mensaje)
        
        if exito:
            QMessageBox.information(self, "‚úÖ √âxito", mensaje)
        else:
            QMessageBox.critical(self, "‚ùå Error", mensaje)

def mostrar_dialogo_build_deploy(parent=None):
    """Funci√≥n para mostrar el di√°logo de build & deploy"""
    dialogo = DialogoBuildDeploy(parent)
    dialogo.exec_()

# Para probar directamente
if __name__ == "__main__":
    from PyQt5.QtWidgets import QApplication
    app = QApplication([])
    dialogo = DialogoBuildDeploy()
    dialogo.show()
    app.exec_()